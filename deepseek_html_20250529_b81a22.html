<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>CesiumJS Viewer with 360 Image and Vector Layers</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<!-- Switch to unminified Cesium for better error messages -->
<script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/CesiumUnminified/Cesium.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marzipano@0.10.1/dist/marzipano.js"></script>
<link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet"/>
<style>
    /* ... (existing styles remain unchanged) ... */
</style>
</head>
<body>
<div id="cesiumContainer"></div>
<div id="imagePopup">
  <span class="close-btn" onclick="document.getElementById('imagePopup').style.display='none';">✖</span>
  <div id="pano"></div>
  <div id="popupLabel"><strong>Label</strong></div>
</div>
<div id="vectorPopup">
  <div class="vector-popup-header">
    <h3 id="vectorPopupTitle">Feature Details</h3>
    <span class="vector-close-btn" onclick="document.getElementById('vectorPopup').style.display='none';">✖</span>
  </div>
  <div id="vectorPopupContent"></div>
</div>

<script type="module">
    // Updated Ion token
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1YzAwNWVmYy00MThkLTRlZDItOTUwNC1mYWJkZGRkNmJiOTMiLCJpZCI6MzA0NTQyLCJpYXQiOjE3NDg1MTUyMjJ9.BkEDuO-b3vd84Mi1tuCMJL2XoadyIR7OWvG72M2ofAg';

    async function init() {
      const viewer = new Cesium.Viewer('cesiumContainer', {
        terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(1),
        baseLayerPicker: true,
        timeline: false,
        animation: false,
        infoBox: false,
        selectionIndicator: false
      });

      viewer.scene.globe.depthTestAgainstTerrain = true;

      // Load camera points GeoJSON
      const cameraGeojsonUrl = 'camera_points_final.geojson';
      try {
        const cameraDataSource = await Cesium.GeoJsonDataSource.load(cameraGeojsonUrl, {
          clampToGround: false
        });
        viewer.dataSources.add(cameraDataSource);
        viewer.flyTo(cameraDataSource);
        
        // ... (camera points processing code remains the same) ...
      } catch (cameraError) {
        console.error("Error loading camera points:", cameraError);
      }

      // ====== IMPROVED VECTOR DATA LOADING ======
      const vectorGeojsonUrl = 'https://raw.githubusercontent.com/GeorgeHackett123/Cesium_Viewer/de9d065eb8e3a66f1afddefd73d906c8b5969d6e/lines.geojson';
      
      try {
        console.log("Loading vector data from:", vectorGeojsonUrl);
        
        // Step 1: Fetch the GeoJSON data
        const response = await fetch(vectorGeojsonUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const geojson = await response.json();
        console.log("GeoJSON data received:", geojson);
        
        // Step 2: Validate GeoJSON structure
        if (!geojson.type || geojson.type !== "FeatureCollection") {
          throw new Error("Invalid GeoJSON: Not a FeatureCollection");
        }
        
        if (!geojson.features || !Array.isArray(geojson.features)) {
          throw new Error("Invalid GeoJSON: Missing features array");
        }
        
        console.log(`GeoJSON contains ${geojson.features.length} features`);
        
        // Step 3: Create and load data source
        const vectorDataSource = new Cesium.GeoJsonDataSource();
        await vectorDataSource.load(geojson, {
          clampToGround: false, // Disable clamping for debugging
          stroke: Cesium.Color.RED, // Use red for better visibility
          strokeWidth: 3
        });
        
        viewer.dataSources.add(vectorDataSource);
        console.log("Vector data processed successfully");
        
        // Step 4: Style features
        const vectorEntities = vectorDataSource.entities.values;
        console.log(`Found ${vectorEntities.length} vector entities`);
        
        for (let i = 0; i < vectorEntities.length; i++) {
          const entity = vectorEntities[i];
          console.log(`Processing entity ${i}:`, entity);
          
          try {
            if (entity.polyline) {
              // Simple style for lines
              entity.polyline.material = Cesium.Color.CYAN;
              entity.polyline.width = 4;
              console.log(`Styled line entity: ${entity.id || i}`);
            }
            
            // Add metadata property
            entity.vectorData = true;
          } catch (entityError) {
            console.error(`Error styling vector entity ${i}:`, entityError);
          }
        }
      } catch (error) {
        console.error("Error loading vector data:", error);
        // Show detailed error message
        const errorMessage = document.createElement('div');
        errorMessage.style.position = 'absolute';
        errorMessage.style.top = '10px';
        errorMessage.style.left = '10px';
        errorMessage.style.backgroundColor = 'rgba(255,0,0,0.7)';
        errorMessage.style.color = 'white';
        errorMessage.style.padding = '10px';
        errorMessage.style.borderRadius = '5px';
        errorMessage.style.zIndex = '1000';
        errorMessage.innerHTML = `
          <h3>Vector Data Error</h3>
          <p><strong>${error.message}</strong></p>
          <p>Check console for details</p>
        `;
        document.body.appendChild(errorMessage);
        
        // Try to add sample line for debugging
        try {
          const sampleLine = viewer.entities.add({
            name: 'Sample Line',
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray([
                -0.1278, 51.5074, // London
                -0.1478, 51.5074  // Nearby point
              ]),
              width: 5,
              material: Cesium.Color.GREEN
            }
          });
          console.log("Added sample line for debugging:", sampleLine);
        } catch (sampleError) {
          console.error("Couldn't add sample line:", sampleError);
        }
      }

      // ... (existing click handler code) ...
    }

    // Add error handling for the entire initialization
    init().catch(error => {
      console.error("Fatal error during initialization:", error);
      const fatalError = document.createElement('div');
      fatalError.style.position = 'absolute';
      fatalError.style.top = '50%';
      fatalError.style.left = '50%';
      fatalError.style.transform = 'translate(-50%, -50%)';
      fatalError.style.backgroundColor = 'rgba(255,0,0,0.8)';
      fatalError.style.color = 'white';
      fatalError.style.padding = '20px';
      fatalError.style.borderRadius = '10px';
      fatalError.style.zIndex = '1000';
      fatalError.style.textAlign = 'center';
      fatalError.innerHTML = `
        <h2>Application Error</h2>
        <p><strong>${error.message}</strong></p>
        <p>Check browser console for details</p>
      `;
      document.body.appendChild(fatalError);
    });
</script>
</body>
</html>